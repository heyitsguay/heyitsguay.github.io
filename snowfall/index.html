<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snow Window (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.8); z-index: 10; flex-direction: column;
        }
        #debug {
            position: absolute; top: 10px; left: 10px; color: lime; 
            pointer-events: none; white-space: pre; z-index: 5;
            text-shadow: 1px 1px 0 #000;
        }
        button {
            padding: 15px 30px; font-size: 1.2rem; color: white; background: #4488ff;
            border: none; border-radius: 8px; cursor: pointer; margin-top: 10px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
</head>
<body>

<div id="debug">Waiting for sensor...</div>

<div id="overlay">
    <button id="startBtn">Enable Sensors & Start</button>
    <div style="color:#888; margin-top:10px; font-size:0.8rem">Requires HTTPS (or localhost)</div>
</div>
<canvas id="glcanvas"></canvas>

<script>
/**
 * CONFIGURATION
 */
const CONFIG = {
    particleCount: 10000,
    gravity: 0.35,
    windStrength: 0.0,
    brownianStdDev: 0.02,
    baseSize: 40.0,
    boxSize: 20.0,
    fadeDist: 15.0
};

// Global State
let particles = null;
let gl, program, positionBuffer;
let projectionMatrix = mat4.create();
let viewMatrix = mat4.create();
let sensorQ = quat.create(); 
let time = 0;
let isRunning = false;

// Buffers for sensor smoothing
let targetQ = quat.create();

/**
 * SHADERS
 */
const vsSource = `
    attribute vec3 a_position;
    uniform mat4 u_view;
    uniform mat4 u_projection;
    uniform float u_baseSize;
    varying float v_depth;

    void main() {
        vec4 viewPos = u_view * vec4(a_position, 1.0);
        gl_Position = u_projection * viewPos;
        v_depth = -viewPos.z;
        
        // Size attenuation
        gl_PointSize = u_baseSize * (1.0 / length(viewPos.xyz));
    }
`;

const fsSource = `
    precision mediump float;
    uniform float u_fadeDist;
    varying float v_depth;

    void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);
        float dist = length(coord);
        if (dist > 0.5) discard;

        float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
        
        // Distance fading
        float depthAlpha = 1.0 - smoothstep(0.0, u_fadeDist, v_depth);
        float closeAlpha = smoothstep(0.5, 2.0, v_depth); 

        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * depthAlpha * closeAlpha);
    }
`;

/**
 * CORE FUNCTIONS
 */
function init() {
    const canvas = document.getElementById('glcanvas');
    gl = canvas.getContext('webgl');
    if (!gl) return alert("WebGL not supported");

    resize();
    window.addEventListener('resize', resize);

    // Setup Program
    const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    program = createProgram(gl, vs, fs);

    positionBuffer = gl.createBuffer();

    initParticles();
    
    // GL State
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(0.02, 0.02, 0.05, 1.0);

    setupGUI();
    
    if (!isRunning) {
        isRunning = true;
        requestAnimationFrame(render);
    }
}

function initParticles() {
    // Re-allocate array
    particles = new Float32Array(CONFIG.particleCount * 3);
    for (let i = 0; i < CONFIG.particleCount; i++) {
        particles[i*3+0] = (Math.random() - 0.5) * CONFIG.boxSize;
        particles[i*3+1] = (Math.random() - 0.5) * CONFIG.boxSize;
        particles[i*3+2] = (Math.random() - 0.5) * CONFIG.boxSize;
    }

    // Update GL Buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, particles, gl.DYNAMIC_DRAW);
    
    const loc = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 0, 0);
}

function render(now) {
    const dt = 0.016;
    time += dt;

    // --- 1. Physics (CPU) ---
    const gustX = Math.sin(time * 0.5) * CONFIG.windStrength;
    const gustZ = Math.cos(time * 0.3) * CONFIG.windStrength;
    const limit = CONFIG.boxSize / 2;

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const idx = i * 3;
        
        // Gravity
        particles[idx + 1] -= CONFIG.gravity * dt;
        
        // Wind & Brownian
        particles[idx] += (gustX + (Math.random()-0.5)*CONFIG.brownianStdDev) * dt;
        particles[idx + 2] += (gustZ + (Math.random()-0.5)*CONFIG.brownianStdDev) * dt;

        // Wrap Logic (Box)
        if (particles[idx+1] < -limit) {
            particles[idx+1] = limit;
            particles[idx] = (Math.random() - 0.5) * CONFIG.boxSize;
            particles[idx+2] = (Math.random() - 0.5) * CONFIG.boxSize;
        }
    }

    // --- 2. Update GPU ---
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, particles);

    // --- 3. View Matrix ---
    // Smoothly interpolate current sensor Q towards target Q
    quat.slerp(sensorQ, sensorQ, targetQ, 0.1);
    
    let rotationMat = mat4.create();
    mat4.fromQuat(rotationMat, sensorQ);
    mat4.invert(viewMatrix, rotationMat);

    // --- 4. Draw ---
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);
    
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "u_projection"), false, projectionMatrix);
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "u_view"), false, viewMatrix);
    gl.uniform1f(gl.getUniformLocation(program, "u_baseSize"), CONFIG.baseSize);
    gl.uniform1f(gl.getUniformLocation(program, "u_fadeDist"), CONFIG.fadeDist);

    gl.drawArrays(gl.POINTS, 0, CONFIG.particleCount);

    requestAnimationFrame(render);
}

/**
 * ORIENTATION HANDLER (ROBUST)
 */
function handleOrientation(event) {
    const debug = document.getElementById('debug');
    
    // Check if sensors are dead
    if (event.alpha === null && event.beta === null) {
        debug.innerText = "Sensor Error: Null Data.\nAre you using HTTPS?";
        return;
    }

    // Raw Euler Angles
    const alpha = event.alpha ? event.alpha * (Math.PI / 180) : 0;
    const beta  = event.beta  ? event.beta  * (Math.PI / 180) : 0;
    const gamma = event.gamma ? event.gamma * (Math.PI / 180) : 0;
    
    // Screen Orientation (Landscape vs Portrait)
    const screenAngle = window.screen.orientation ? window.screen.orientation.angle * (Math.PI / 180) : 0;

    debug.innerText = `A:${event.alpha.toFixed(1)}\nB:${event.beta.toFixed(1)}\nG:${event.gamma.toFixed(1)}`;

    // Create quaternions for each axis (Standard Intrinsic Rotation Z-X-Y)
    const qAlpha = quat.create(); 
    quat.setAxisAngle(qAlpha, [0, 0, 1], alpha); 
    
    const qBeta = quat.create(); 
    quat.setAxisAngle(qBeta, [1, 0, 0], beta);
    
    const qGamma = quat.create(); 
    quat.setAxisAngle(qGamma, [0, 1, 0], gamma);

    // Combine: q = Alpha * Beta * Gamma
    const qOrient = quat.create();
    quat.multiply(qOrient, qAlpha, qBeta);
    quat.multiply(qOrient, qOrient, qGamma);

    // Adjust for Screen Rotation (minus screenAngle along Z)
    const qScreen = quat.create();
    quat.setAxisAngle(qScreen, [0, 0, 1], -screenAngle);
    quat.multiply(qOrient, qOrient, qScreen);

    // Final Adjustment: Align "Phone Flat" to "Camera Down"
    // By default, identity quaternion looks -Z.
    // We rotate -90 around X so that "Identity" means looking at Horizon, 
    // and "Looking Down" aligns with -Y.
    const qOffset = quat.create();
    quat.setAxisAngle(qOffset, [1, 0, 0], -Math.PI / 2);
    
    quat.multiply(targetQ, qOrient, qOffset);
}

/**
 * UTILS & BOILERPLATE
 */
function resize() {
    const c = document.getElementById('glcanvas');
    c.width = window.innerWidth;
    c.height = window.innerHeight;
    mat4.perspective(projectionMatrix, Math.PI / 4, c.width / c.height, 0.1, 100.0);
}

function createShader(gl, type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
    return s;
}

function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    return p;
}

function setupGUI() {
    const gui = new lil.GUI();
    // Particle Count Trigger: Re-runs initParticles on change
    gui.add(CONFIG, 'particleCount', 5000, 250000, 5000)
        .name("Count")
        .onFinishChange(initParticles);
        
    gui.add(CONFIG, 'gravity', 0.01, 1).name("Gravity");
    gui.add(CONFIG, 'windStrength', 0.0, 10.0).name("Wind");
    gui.add(CONFIG, 'baseSize', 10.0, 100.0).name("Size");
}

document.getElementById('startBtn').addEventListener('click', async () => {
    document.getElementById('overlay').style.display = 'none';
    init();

    // iOS Request
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
            const r = await DeviceOrientationEvent.requestPermission();
            if (r === 'granted') window.addEventListener('deviceorientation', handleOrientation);
        } catch (e) { console.error(e); }
    } else {
        // Android / Desktop
        window.addEventListener('deviceorientation', handleOrientation);
    }
});
</script>
</body>
</html>